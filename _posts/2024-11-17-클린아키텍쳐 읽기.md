---
title: 클린아키텍처 - 1 초반부
description: >-
  클린 아키텍처 깨끗한 아키텍처란 무엇인가? 책읽기..
author: dgkim
date: 2024-11-24 15:05:00 +0900
categories: [설계]
tags: [독서,클린아키텍처,설계]
pin: false
media_subpath: '/posts/20241117'
comments: true
---

# 클린아키텍처 
설계에 원칙을 알려준다는 점에서 좋은 책이다. 원칙이란 것은 지켰을 때 유의미한 가치를
전해준다. 물론 원칙에 너무 억매이는 것도 좋지 않긴 하지만 원칙에서 벗어날 때는 심사
숙고가 있어야 한고 생각한다.

## 1. SOLID
책에서는 좋은 소프트웨어 시스템은 좋은 코드라는 벽돌을 사용해 쌓는다고 했다. SOLID는
좋은 코드의 5원칙이다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다고 한다.
1. 변경에 유연하다.
2. 이해하기 쉽다.
3. 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.
> 책에서는 컴포넌트의 비중이 컷다. 

경험상 SI에서는 화면 단위로 개발을 진행하는 경우가 많았다. 이 경우는 언어를 막론하고
자신이 만든 함수를 누군가 사용하는 경우는 거의 없었다. 이 경우는 그다지 의미가 없지
않았나 싶다.
뭔가 재사용 가능한 오래 쓰도록 의도하고 만든 코드는 반드시 호출자를 배려 해야한다.
그게 미래의 내가 될 수도 있고, 다른 사람이 될 수도 있다. 코드의 내용을 봐야 무슨일을
하는지 알 수 있는 코드는 아무리 잘 만들어져있어도 사용이 잘 안된다. 주석을 잘 달라는
얘기는 아니다.

- ***SRP(Single Responsibility Principle)***: 소프트웨어 모듈은 변경의 이유가 단 하나여야만 한다.
- ***OCP(Open-Closed Principle)*** : 코드는 수정하기보다는 반드시 새로운 코드를 추가하는 방식으로
시스템 행위를 변경할 수 있도록 설계해야한 한다.
- ***LSP(Liskov Subsitution Principle)***: 하나의 타입에서 파생된 하위 타입의 구성요소들은 치환 가능해야 한다.
- ***ISP(Interface Segregation Principle)***: 사용하지 않은 것에 의존하지 않아야 한다.
- ***DIP(Dependency Inversion Principle)***: 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 
의존해서는 안된다. 

## 2. 컴포넌트 
콤포넌트는 배포 단위이다. java에서는 jar, .Net 에서는 .dll 혹은 .exe 파일 등이다. 
java에서는 jar를 묶어서 war로 만들수도 있다. 컴포넌트는 어떤 식으로 배포되든 독립적으로
배포&개발 될 수 있도록 설계 되어야 한다.

컴포넌트의 응집도에 관한 3가지 원칙.(클래스를 어떻게 배치할 것인가)
- ***REP(Reuse/Release Equivalence Principle)***: 컴포넌트를구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야한다.
하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리즈할 수 있어야 한다. 릴리스 번호도 같아야 하며, 릴리스로 추적 관리되고 
릴리스로 문서도 포함되어야 한다.
- ***CCP(Common Closure Principle)***:  동일한 이유로 동일한 시접에 변경되는 클래스를 같은 컴포넌트로 묶어라.
- ***CRP(Common Reuse Principle)***: 컴포넌트 사용자들에게 필요하지 않는 것에 의존하게 강요하지 말라.

컴포넌트 응집도에 대한 세 원칙은 서로 상충된다. ***REP***, ***CCP***는 컴포넌트를 크게 만든다.
***REP,CRP***는 컴포넌트 변경이 너무 빈번해진다. ***CRP***, ***CCP***는 재사용이 어렵다.
어떻게 만들지는 개발 당시 혹은 리팩토링시 처한 현실을 반영하여 균현을 잘 잡아야 한다. 

컴포넌트 결합에 대한 원칙
- ***ADP(Acyclic Dependencies Principle)***: 컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
- ***SDP(Stable Dependencies Principle)***: 더 안정된 쪽에 의존하라.(외부로 의존하는 것이 많으면 불안정하다.)
- ***SAP(Stable Abstration Principle)***: 컴포넌트는 안정된 정도 만큼만 추상화되어야 한다.

추상화 정도가 높고, 안정된 정도가 높으면 쓸모 없어질 가능성이 높다.
추상화 정도가 낮고, 안정된 정도가 낮으면 고통의 코드가 될 가능성이 높다. 

적당히 해야 한다.... 책에서는 그래프와 지표를 가지고 컴포넌트의 안정성과 추상화 정도를 측정했었다.

추상화 정도 : (추상 클래스 or 인터페이스 갯수) / 전체 클래스
안정성 정도 : 외부에 의존하는 갯수 / (들어오는 의존가 + 나가는 의존 갯수)

## 3. 아키텍처
소프트웨어 시스템의 아키텍처란 시스템을 쉽게 개발, 배포 운영, 유지보수 되도록 컴포넌트를
분할하고, 배치하고 서로 의사소통하도록 만든 시스템의 형태이다.

> 이러한 일을 용이하게 만들기 위해서는 가능한 많은 선택지를 오래도록 남겨두는 전략을 따라야 한다.

처음에는 얼핏 이해가 가지 않았다. 어떤 언어로 어떤 프레임웤을 써서, 어떤 영속성 프로그램까지 정하
는 경우가 많았다.

### 3.1 선택사항 열어 두기
소프트웨어를 쉽게 변경하기 위한 방법으로는 해당 결정사항을 미뤄두는 전략을 취한다. 대신 시스템의
업무규칙과 업무절차를 구체화 한다. 업무 규칙과 업무 절차는 시스템의 정책이라고 한다.

- 개발 초기에는 데이터베이스 시스템을 선택할 필요가 없다.
- 개발 초기에는 웹서버를 선택할 필요가 없다.
- 개발 초기에는 REST를 적용할 필요가 없다.
- 개발 초기에는 의존성 주입 프레임워크를 적용할 필요가 없다.

### 3.2 결합분리
- ***계층 결합 분리***: UI, 업무로직, 데이터베이스 등을 구분한다.

시스템 전체 구조에서 UI와 업무로직은 각기 다른 이유로 다른 속도로 진화할 것이 예상 되기 때문이다.
업무로직과 데이터베이스를 분리한다. 데이터베이스, 쿼리, 스키마는 기술적인 세부사항이며 UI와 업무규칙에
관계가 적다.

- ***유즈케이스 결합 분리***: 주문 추가, 주문 삭제라는 유즈 케이스 구분한다.

분리된 내용은 주문 추가 UI, 주문 추가 업무로직, 주문 추가 데이터베이스 리포, 
주문 삭제 UI. 주문 삭제 업무로직, 주문 삭제 데이터베이스 리포 이다.  

### 3.3 결합분리모드

- ***소스 수준 분리 모드*** : 소스 코드 모듈 사이의 의존성 제어. 모노리틱 구조.
- ***배포 수준 분리 모드*** : jar, dll 공유 라이브러리와 같이 배포 가능한 단위들 의 의존성 제어. 
- ***서비스 수준 분리 모드*** : 의존하는 수준을 최소 단위까지 낮출수 있고 네트워크 패킷을 통해서만 통신하도록 만들 수 있다.

어떤 모드가 가장 좋은가? 프로젝트 초기 단계는 어떤 모드가 최선인지 알기 어렵다는 것이 답이다.
프로젝트가 진화해가며 최적의 모드는 달라 진다. 좋은 아키텍처는 이러한 변경을 예측하여 무리없이
 적은 노력으로도 반영 할 수 있도록 한다.

### 3.3 경계
아키텍처는 시스템에 경계선을 긋는 작업이다. 관련이 있는 것과 없는 것 사이에 선을 긋는다.
예를 들어 GUI와 업무 규칙과는 관련이 없기 때문에, 이 둘 사이에는 반드시 선이 있어야 한다.

***경계 횡단하기***: 런타임에 경계를 횡단한다는 것은 한쪽 끝에서 다른쪽 끝으로 호출이 이어지는 것을 의미한다.

*. 경계에는 인터페이스나 추상 클래스가 존재한다.

***수준***: 입력과 출력까지의 거리이고, 이 거리가 멀면 수준이 높다라고 얘기한다.

### 3.4 업무규칙
***엔티티***: 핵심 업무 데이터를 기반으로 동작하는 핵심 업무 규칙을 구현한 함수들로 구성된다. 
***유스케이스***: 사용자가 제공해야 하는 입력, 보여줄 출력, 처리단계가 기술된 애플리케이션에 특화된 업무 규칙이다.
업무 규칙을 구현한 하나 이상의 함수로 구성된다.

*. 모든 업무 규칙이 엔티티처럼 순수한 것은 아니다. 유스케이스는 엔티티에 의존한다. 엔티티는 아니다.

> 소스크드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

## 4. 정리

많은 내용이 있었으나, 일단 꼭 기억해야하고, 정리가 쉬운것 위주로 먼저 정리한다.
후에 조금식 내용을 더해도 될 것 같다.


> DRY(Don't Repeat Yourself)

> YAGNI(you aren't going to need it)

> 오버엔지니어링이 언더 엔지니어링보다 나쁘다.